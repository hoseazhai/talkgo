

#### 内存映射

- 内存
指的是物理内存。物理内存也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）

- 内核和进程
只有内核才可以直接访问物理内存

##### 进程和内存
Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内。(每一个进程的地址空间都包括内核空间和用户空间)

- 虚拟地址空间
拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，我画了两张图来分别表示它们的虚拟地址空间，如下所示
![](/uploads/talkgo/images/m_da8a7016462317bb8b4b5dbf2a7575cc_r.png)

- 内存映射
并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的，内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示
![](/uploads/talkgo/images/m_8b1e8bd55a24ce4400ef0fdd9ef527ec_r.png)
说明：
页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

- 最小映射单位
通常是4KB，而每一次内存映射都需要关联4KB或者4KB整数倍的内存空间

为了解决页表项过多的问题，Linux 提供了两种机制，也就是多级页表和大页（HugePage）
inux 用的正是四级页表来管理内存页，如下图所示，虚拟地址被分为 5 个部分，前 4 个表项用于选择页，而最后一个索引表示页内偏移。
![](/uploads/talkgo/images/m_9e9a7a32436aede91925058b5d64fd28_r.png)

#### 虚拟内存空间分布
户空间内存，其实又被分成了多个不同的段。以 32 位系统为例，我画了一张图来表示它们的关系。
![](/uploads/talkgo/images/m_d9dad3295dfb5c96a7e845a8c9bbd7cf_r.png)
通过这张图你可以看到，用户空间内存，从低到高分别是五种不同的内存段
- 只读段，包括代码和常量等。
- 数据段，包括全局变量等。
- 堆，包括动态分配的内存，从低地址开始向上增长。
- 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
- 栈，包括局部变量和函数调用的上下文等。
- 栈的大小是固定的，一般是 8 MB。

在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。

##### 内存分配与回收

###### 内存分配



- malloc（）是C标准库提供的内存分配函数，对应到系统调用上有两种实现方式：brk（）和mmap（）

-  brk（）：主要针对小块内存（小于128K），通过移动堆顶的位置来分配内存。这些内存释放后并不会立即归还系统，而是被缓存可重复利用
  -  优点：减少缺页异常的发生，提高内存访问效率
  - 缺点： 在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片
- mmap（）：大块内存（大于128K），在文件映射段找一块空闲内存进行分配
  -  优先：释放后会直接归还系统。
  -  缺点：每次mmap都会发生缺页异常，在内存工作繁忙时，频繁的内存分配导致大量的缺页异常，使内核的管理负担增大。

注意： 当发生了以上两种调用时，其实并没有真正分配内存。这些内存都只在首次访问时才分配。

伙伴系统： linux用伙伴系统来管理内存分配，以页为单位来管理，并且会通过相邻页的合并，减少内存碎片化。

+ 分配不到1K内存时的过程：用户空间的malloc通过brk（）分配内存，在释放时并不立即归还系统，而是缓存起来重复利用，在内核空间，LInux则通过slab分配器来管理小内存，可以把slab看成构建在伙伴系统上的一个缓存，主要作用就是分配并释放内核中的小对象

######  内存回收

- 回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；
- 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；
- 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。

##### 内存使用情况
命令free显示的是整个系统的内存使用情况
```
[root@nginx-e ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           3790        2835         196           0         758         702
Swap:             0           0           0
```

- 第一列，total 是总内存大小；
- 第二列，used 是已使用内存的大小，包含了共享内存；
- 第三列，free 是未使用内存的大小；
- 第四列，shared 是共享内存的大小；
- 第五列，buff/cache 是缓存和缓冲区的大小；
- 最后一列，available 是新进程可用内存的大小。

top看进程的内存使用情况
```
PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                           
17778 root      10 -10  132008  14992   5840 S   6.7  0.4 703:32.04 AliYunDun                                                                                         
    1 root      20   0  190784   3380   2056 S   0.0  0.1   3:44.28 systemd 
```

- VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。
- RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。
- SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
- %MEM 是进程使用物理内存占系统总内存的百分比。

