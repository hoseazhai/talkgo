#### 疑问

> 进程在竞争 CPU 的时候并没有真正运行，为什么还会导致系统的负载升高呢

#### 基础概念

- CPU 寄存器
> CPU 寄存器是CPU内置的容量小、但速度极快的内存。

- 程序计数器
> 程序计数器是用来存储CPU正在执行的指令位置、或者即将执行的下一条指令位置。

- CPU上下文
> CPU上下文是指CPU寄存器和程序计数器都是 CPU 在运行任何任务前，必须的依赖环境，

- CPU 上下文切换
> CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

根据任务的不同上下文切换分为

1. 进程上下文切换

2. 线程上下文切换

3. 中断上下文切换

##### 进程上下文切换

- 进程用户态
> 进程在用户空间执行的时候

- 进程的内核态
> 而陷入内核空间执行的时候

###### 系统调用的例子
> 当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件

例子的上下文切换
> CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换

###### 系统调用和进行上下文切换的区别
- 进程上下文切换
> 是指从一个进程切换到另一个进程运行，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态

- 系统调用
>而系统调用过程中一直是同一个进程在运行,不会涉及到虚拟内存等进程用户态的资源。**系统调用过程通常称为特权模式切换，而不是上下文切换**。

- 区别
>进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈.

- 上下文切换需要消耗CPU资源
>进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间,**这个也会让负载升高**

###### 进程调度导致上下文切换，何时发生进程调度
1. 第一种场景
> 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。

2. 第二种场景
>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。

3. 第三种场景
>当进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度。

4. 第四种场景
>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。

5. 第五种场景
>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

##### 线程上下文切换

线程上下文切换的场景

1.  第一种场景
>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。

2. 第二种场景，
>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据例如栈、寄存器等不共享的数据。

**虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源**

##### 中断上下文切换

- 中断上下文切换
>**同一个 CPU 来说，中断处理比进程拥有更高的优先级.中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件**。跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

总结
> CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注。但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。

#### 分析上下文切换情况
工具vmstat，pidstat，sysbench

使用vmstat分析
```shell
# 每隔5秒输出1组数据
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0
```

- cs（context switch）是每秒上下文切换的次数。
- in（interrupt）则是每秒中断的次数。
- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
- b（Blocked）则是处于不可中断睡眠状态的进程数。
- us（user）用户空间CPU利用率
- sy（system）内核空间CPU利用率

pidstat使用的例子
```shell
# 每隔5秒输出1组数据
$ pidstat -w 5
Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)

08:18:26      UID       PID   cswch/s nvcswch/s  Command
08:18:31        0         1      0.20      0.00  systemd
08:18:31        0         8      5.40      0.00  rcu_sched
...
```

- cswch含义
>表示每秒自愿上下文切换（voluntary context switches）的次数，所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

- nvcswch含义
>表示每秒非自愿上下文切换（non voluntary context switches）的次数，非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

sysbench 来模拟系统多线程调度切换的情况


```shell

# 在三个窗口中执行以下命令

# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run
# 每隔1秒输出1组数据（需要Ctrl+C才结束）
$ vmstat 1
# 每隔1秒输出1组数据（需要 Ctrl+C 才结束）# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
$ pidstat -w -u 1
# 每隔1秒输出一组数据（需要 Ctrl+C 才结束）# -wt 参数表示输出线程的上下文切换指标，-t 参数后，才会输出线程的指标。
$ pidstat -wt 1
# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
```
- 中断类型分析
> 中断信息是从/proc/interrupts 这个只读文件中读取。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况

- 重调度中断（RES）
>重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）

#### 案例分析过程（摘自评论区）

- 查看分析负载
>负载高的话有三种情况，首先是cpu使用率 ，其次是io使用率 ，之后就是两者都高 。

- cpu 使用率高的情况
1. 可能确实是使用率高
2. 进程太多切换上下文频繁
3. 进程内线程的上下文切换频繁
4. 中断次数过多

- io 使用率高 
>说明 io 请求比较大， 可能是 文件io 、 网络io 。

##### 工具 ：

- 系统负载
>uptime （ watch -d uptime）看三个阶段平均负载

- 系统整体情况
>mpstat （mpstat -p ALL 3） 查看 每个cpu当前的整体状况，可以重点看用户态、内核态、以及io等待三个参数

- 系统整体的平均上下文切换情况
>vmstat (vmstat 3) 可以重点看 r （进行或等待进行的进程）、b （不可中断进程/io进程） 、in （中断次数） 、cs（上下文切换次数）

- 查看详细的上下文切换情况 
>pidstat （pidstat -w(进程切换指标)/-u（cpu使用指标）/-wt(线程上下文切换指标)） 注意看是自愿上下文切换、还是被动上下文切换

- io使用情况 ： iostat

